# 迁移命令

一旦迁移被[配置](/zh-CN/guide/migration-setup-and-overview#setup)，您就可以通过命令行使用它。

## 创建和删除数据库

通过命令行创建和删除数据库：

```sh
npm run db create
npm run db drop
```

除非 `databaseURL` 包含数据库超级用户的凭据，否则这些命令将要求输入数据库管理员的用户名和密码。

如果为连接选择了自定义 `schema`，`db create` 还会尝试创建此 schema（如果已存在则不会失败）。

## 重置数据库

`reset` 是一个快捷命令，用于删除、创建和迁移数据库。

```sh
npm run db reset
```

## pull

此命令用于通过检查现有数据库生成文件。

当迁移工具与 OrchidORM 一起使用时，`pull` 命令会为您的项目生成表类文件和迁移文件。

当单独使用时，它仅生成迁移文件。

```sh
npm run db pull
# 或
pnpm db pull
```

目前，它支持生成以下内容的代码：

- schemas
- 表
- 带有所有可能列选项的列
- 枚举
- 主键
- 外键
- 索引
- `EXCLUDE` 约束
- 数据库 `CHECK` 约束
- 域类型
- 视图（仅在迁移中）
- 时间戳默认值 `current_timestamp`、`transaction_timestamp()` 被简化为等效的 `now()`
- （对于 ORM）通过分析外键定义 `belongsTo` 和 `hasOne` 关系

### 如何处理 `updatedAt` 和 `createdAt` 时间戳

假设我们在数据库中有两个表，一个使用 camelCase 列，另一个使用 snake_case：

```sql
CREATE TABLE "camel" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "camelCaseColumn" text NOT NULL,
  "createdAt" timestamptz DEFAULT now(),
  "updatedAt" timestamptz DEFAULT now()
);

CREATE TABLE "snake" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "snake_case_column" text NOT NULL,
  "created_at" timestamptz DEFAULT now(),
  "updated_at" timestamptz DEFAULT now()
);
```

当 snakeCase 为 `false`（默认值）时，`db pull` 将生成以下迁移，其中 snake_case 列被显式命名并使用 `timestampsSnakeCase`：

```ts
import { change } from '../dbScript';

change(async (db) => {
  await db.createTable('camel', (t) => ({
    id: t.identity().primaryKey(),
    camelCaseColumn: t.text(),
    ...t.timestamps(),
  }));

  await db.createTable('snake', (t) => ({
    id: t.identity().primaryKey(),
    snakeCaseColumn: t.name('snake_case_column').text(),
    updated_at: t.timestamps().updatedAt,
    created_at: t.timestamps().createdAt,
  }));
});
```

当 snakeCase 为 `true` 时，`db pull` 将生成以下迁移，这次 camelCase 列被显式命名，时间戳没有快捷方式：

```ts
import { change } from '../dbScript';

change(async (db) => {
  await db.createTable('camel', (t) => ({
    id: t.identity().primaryKey(),
    camelCaseColumn: t.name('camelCaseColumn').text(),
    createdAt: t
      .name('createdAt')
      .timestamp()
      .default(t.sql`now()`),
    updatedAt: t
      .name('updatedAt')
      .timestamp()
      .default(t.sql`now()`),
  }));

  await db.createTable('snake', (t) => ({
    id: t.identity().primaryKey(),
    snakeCaseColumn: t.text(),
    ...t.timestamps(),
  }));
});
```

如果数据库中的时间戳没有时区，请使用 `timestampNoTZ`。

### 自定义和未知列

如果列类型是用户定义的自定义类型，或者尚不支持，`db pull` 将记录警告并输出如下列：

```ts
await db.createTable('table', (t) => ({
  column: t.type('unsupported_type'),
}));
```

它可以工作，只需在应用程序中使用 `t.type` 定义列时，您需要使用 `as` 方法将其视为另一列：

```ts
export class Table extends BaseTable {
  readonly table = 'table';
  columns = this.setColumns((t) => ({
    // 将不支持的类型视为文本
    column: t.type('unsupported_type').as(t.text()),
  }));
}
```

## 新的空白迁移

使用 `new` 命令生成一个新的迁移文件：

```sh
npm run db new migrationName
# 或
pnpm db new migrationName
```

迁移名称可以是任何字符串，应该对团队具有描述性。

如果迁移名称匹配已知模式之一，它将生成一个模板：

- `create[table]` 创建一个新表，例如：`createProduct`
- `drop[table]` 删除一个表，例如：`dropProduct`
- `change[table]` 更改一个表，例如：`changeProduct`
- `add[something]To[table]` 向表中添加列，例如：`addDetailsToProduct`
- `remove[something]From[table]` 从表中移除列，例如：`removeDetailsFromProduct`

## up 或 migrate

`up` 命令将按顺序运行所有尚未应用的迁移。
`migrate` 是一个别名。
应用迁移后，如果存在，将运行 `recurrent` 迁移。

```sh
npm run db up
```

传递一个数字以仅迁移特定数量的迁移：

```sh
npm run db up 3
```

## up 或 migrate force

如果您使用时间戳前缀迁移，此命令可能会很有用。

如果您的同事提交了一个时间戳早于您本地迁移的迁移：

```
migrations/
├── 20221017200326_theirMigration.ts
└── 20221017200326_yourMigration.ts
```

您的迁移已经应用，运行 `migrate` 或 `up` 失败，因为他们的迁移排在上面，运行：

```sh
npm run db up force
```

您的迁移将被回滚，然后两者都将被应用。

`force` 仅在您的迁移尚未提交到远程存储库时使用。

## down 或 rollback

`down` 命令将撤销最后一个应用的迁移。
`rollback` 是一个别名。

```sh
npm run db down
```

传递一个数字以撤销多个最后应用的迁移，或传递 `all` 以撤销所有迁移：

```sh
npm run db down 3
npm run db down all
```

## redo

`down` + `up` 的快捷方式。当您编辑迁移并希望重新应用它时很有用。

默认情况下，回滚并迁移一个迁移。传递一个数字以重新运行多个文件。

如果存在，将运行 `recurrent` 迁移。

```sh
# 重新运行最后一个迁移：
npm run db redo

# 重新运行最后 3 个迁移：
npm run db redo 3
```

## status, s

`status` 或 `s` 命令将在终端显示迁移列表：

```sh
$ pnpm db s

 Database: db-name

 Status | Migration ID | Name
------------------------------------------
   Up   | 0001         | First migration
   Up   | 0002         | Second migration
  Down  | 0003         | Third migration
------------------------------------------
```

添加 `path` 或 `p` 命令参数以输出迁移文件路径：

```sh
$ pnpm db s p

 Database: db-name

 Status | Migration ID | Name
------------------------------------------
   Up   | 0001         | First migration
file:///migrations/0001_first_migration

   Up   | 0002         | Second migration
file:///migrations/0002_second_migration

  Down  | 0003         | Third migration
file:///migrations/0003_third_migration
------------------------------------------
```

## recurrent, rec

`recurrent` 迁移是包含 `SQL` 函数、触发器等的 `SQL` 文件。

`rec` 是一个别名。

所有 `sql` 文件位于 recurrent 目录（默认 `src/db/migrations/recurrent`）
将在运行此命令时并行执行，
以及在运行 `migrate` 或 `redo` 命令后执行。

```sh
npm run recurrent
# 或
npm run rec
```

## rebase

当您从存储库拉取更改时，并且更改包含与您本地已有的迁移具有相同编号的新迁移时，请使用 `rebase`。

假设您本地有以下迁移文件：

- 0001_a.ts
- 0002_b.ts

您的同事提交了他们的工作，其中也包含迁移文件：

- 0001_c.ts
- 0002_d.ts

拉取更改后，您有：

- 0001_a.ts
- 0001_c.ts
- 0002_b.ts
- 0002_d.ts

运行 `pnpm db migrate` 失败，因为编号冲突。运行命令：

```sh
pnpm db rebase
```

它将回滚您的本地迁移 "0001_a.ts" 和 "0002_b.ts"，
将它们重命名为 "0003_a.ts" 和 "0004_b.ts"，并迁移所有文件。

运行命令后的迁移：

- 0001_c.ts
- 0002_d.ts
- 0003_a.ts
- 0004_b.ts

`rebase` 命令依赖于您的本地迁移已应用到数据库的事实。
如果它们尚未应用，并且存在文件 "0001_a.ts" 和 "0001_b.ts"，`rebase` 命令将以交互方式询问保留哪个文件在另一个文件之上。

如果通过配置中的 `migrations` 设置提供迁移（可能对 Vite 有用），`rebase` 将无法工作。

## change-ids

当从时间戳前缀迁移到序列前缀（或反之）时，
运行 `change-ids` 命令以重命名文件并反映数据库中跟踪迁移的更改：

```sh
pnpm db change-ids serial
# 或迁移到时间戳
pnpm db change-ids timestamp
```

序列前缀默认有 4 位数字，您可以通过指定第二个参数使用自定义位数：

```sh
pnpm db change-ids 5
```

运行命令后，在迁移配置中将 `migrationId` 更改为所需的前缀类型。

当 `rake-db` 直接从文件加载迁移（设置了 `migrationsPath` 配置）：

- 该命令将在迁移中创建一个特殊文件：`.rename-to-serial.json`，
  它将在部署到远程服务器后用于重命名数据库中的迁移。
- 迁移文件和数据库条目会自动重命名。

或者，当 `rake-db` 接受迁移数组（设置了 `migrations` 配置）：

- 该命令将生成一个设置 `renameMigrations`，您应该将其复制粘贴到 `rake-db` 配置中。
- 它将输出一系列 `mv` 命令以重命名文件（如果迁移存储在文件中），
  然后您应该导航到迁移目录并应用这些命令。
- 如果迁移未存储在文件中，您将不得不手动重命名迁移对象键。

在部署到将运行迁移的远程服务器后，
它将检测到前缀不匹配，并在上述第一种情况下查找文件，或在第二种情况下查找 `renameMigrations`，
并将已应用迁移的条目重命名到数据库中。

在应用程序部署到所有目标之前，请勿删除 `.rename-to-serial.json` 或 `renameMigrations`。

## 自定义命令

您可以这样配置自定义命令：

```ts
import { rakeDb } from 'orchid-orm/migrations'; // 如果不使用 Orchid ORM，请从 'rake-db' 导入
import { createDb } from 'pqb';
import { config } from './config';

export const change = rakeDb(
  // 配置可能有多个数据库数组，用于开发和测试
  config.databases,
  {
    commands: {
      async custom(dbConfigs, config, args) {
        // dbConfig 是提供的数据库配置数组
        for (const dbConfig of dbConfigs) {
          const db = createDb(dbConfig);

          // 执行一些查询
          await db('table').insert(someData);

          // 使用后关闭数据库
          await db.close();
        }

        // config 是我们所在的这个配置对象
        config.commands.custom; // 这是我们所在的函数

        // 命令行参数，类型为 string[]
        console.log(args);
      },
    },
  },
);
```

运行此命令将执行查询并将参数 `['one', 'two']` 输出到控制台：

```sh
npm run db custom one two
```
